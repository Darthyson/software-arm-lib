/*
 *  bus.h - Low level EIB bus access.
 *
 *  Copyright (c) 2014 Stefan Taferner <stefan.taferner@gmx.at>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 3 as
 *  published by the Free Software Foundation.
 */
#ifndef sblib_bus_h
#define sblib_bus_h

#include <sblib/core.h>
#include <sblib/eib/com_objects.h>
#include <sblib/eib/telegram.h>

class Bus;


/**
 * Low level class for EIB bus access.
 *
 * When creating a bus object, the handler for the timer must also be
 * created. Example:
 *
 * Bus mybus(timer32_0);
 * BUS_TIMER_INTERRUPT_HANDLER(TIMER32_0_IRQHandler, mybus);
 */
class Bus
{
public:
    /**
     * Create a bus access object.
     *
     * @param timer - The timer to use.
     * @param rxPin - The pin for receiving from the bus, e.g. PIO1_8
     * @param txPin - The pin for sending to the bus, e.g. PIO1_10
     * @param captureChannel - the timer capture channel of rxPin, e.g. CAP0
     * @param matchChannel - the timer match channel of txPin, e.g. MAT0
     */
    Bus(Timer& timer, int rxPin, int txPin, byte captureChannel, byte matchChannel);

    /**
     * Begin using the bus.
     *
     * This powers on all used components.
     * This method must be called before the bus can be used.
     */
    void begin();

    /**
     * End using the bus.
     *
     * This powers the bus off.
     */
    void end();

    /**
     * Test if the bus is idle and no telegram is about to being sent.
     *
     * @return 1 when idle, 0 when not.
     */
    bool idle() const;

    /**
     * Send a telegram. The checksum byte will be added at the end of telegram[].
     * Ensure that there is at least one byte space at the end of telegram[].
     *
     * @param telegram - the telegram to be sent.
     * @param size - the size of the telegram in telegram[], without the checksum
     */
    void send(byte* telegram, int size);

    /**
     * This method is called by the timer interrupt handler.
     */
    void timerInterruptHandler();

    // The state of the lib's telegram sending/receiving
    enum State
    {
        // The lib is idle. No receiving or sending.
        IDLE,

        // The lib is receiving a byte.
        RECV_BYTE,

        // The lib is waiting for the start bit of the next byte.
        RECV_START,

        // Start sending the telegram in sbSendTelegram[].
        SEND_INIT,

        // Start sending the next byte of a telegram
        SEND_START,

        // Send the first bit of the current byte
        SEND_BIT_0,

        // Send the bits of the current byte
        SEND_BYTE,

        // Wait between two sendings
        SEND_WAIT,

        // Finish sending
        SEND_END
    };

    /**
     * Acknowledgement bytes as they are sent on the EIB bus in reply to telegrams.
     */
    enum Ack
    {
        /**
         * Bus short acknowledgment frame: acknowledged
         */
        ACK = 0xcc,

        /**
         * Bus short acknowledgment frame: not acknowledged
         */
        NACK = 0x0c,

        /**
         * Bus short acknowledgment frame: busy
         */
        BUSY = 0xc0,

        /**
         * Bus short acknowledgment frame: not acknowledged & busy
         * Shall be handled as SB_BUS_BUSY
         */
        NACK_BUSY = 0x00
    };

protected:
    /**
     * Prepare the telegram for sending. Set the sender address to our own
     * address, and calculate the checksum of the telegram.
     * Stores the checksum at telegram[length].
     *
     * @param telegram - the telegram to process
     * @param size - the size of the telegram in bytes
     */
    void prepare(byte* telegram, int size) const;

    /**
     * Switch to idle state
     */
    void idleState();

    /**
     * Handle the received bytes on a low level. This function is used by
     * the function TIMER16_1_IRQHandler() to decide about further processing of the
     * received bytes.
     *
     * @param valid - all bytes had correct parity and the checksum is correct.
     */
    void sb_handle_tel(bool valid);

    int sb_index_of_group_addr(int addr) const;

protected:
    Timer& timer;              // The timer that handles the bus
    int txPin;                 // The pin for sending to the bus
    byte rxCaptureChannel;     // The timer capture channel for reception
    byte txMatchChannel;       // The timer match channel for sending
    byte timeMatchChannel;     // The match channel for timeouts
    byte parity;               // The parity bit of the current byte
    byte valid;                // 1 if parity is valid for all bits of the telegram
    byte checksum;             // Checksum of the telegram: 0 if valid at end of telegram
    byte state;                // The state of the receiver/sender, see enum State
    int ownAddr;               // Our own physical address on the bus
    int bitMask;               // The bit mask when receiving or sending a byte
    int bitTime;               // The time in usec since the start bit when receiving a byte
    int currentByte;           // The current byte that is received/sent (incl. the parity)

    Telegram* sendTelegram;         // The telegram to be sent
    Telegram* sendQueuedTelegram;   // The telegram to be sent after sendTelegram is sent

};


/**
 * Create an interrupt handler for the EIB bus access.
 *
 * @param handler - the name of the interrupt handler, e.g. TIMER16_0_IRQHandler
 * @param busObj - the bus object that shall receive the interrupt.
 */
#define BUS_TIMER_INTERRUPT_HANDLER(handler, busObj) \
    extern "C" void handler() { busObj.timerInterruptHandler(); }

/**
 * Get the length of a telegram, including the protocol header but excluding
 * the checksum byte.
 *
 * @param telegram - the telegram to query
 *
 * @return The length of the telegram, excluding the checksum byte.
 */
#define sb_tel_length(telegram) (7 + (telegram[5] & 15))

#endif /*sblib_bus_h*/
