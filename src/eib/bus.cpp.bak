/*
 *  bus.cpp - Low level EIB bus access.
 *
 *  Copyright (c) 2014 Stefan Taferner <stefan.taferner@gmx.at>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License version 3 as
 *  published by the Free Software Foundation.
 */

#include <sblib/eib/bus.h>

#include <sblib/core.h>

/*
 * The timer is used as follows:
 *
 * Capture register CR0 is used for receiving
 * Match register MR0 or MR1 is used as PWM for sending, depending on which output pin is used
 * Match register MR3 is used for timeouts while sending / receiving
 */


// Enable debug statements for debugging the bus access in this file
#define D(x) x
//#define D(x)


// Time from the start of one bit to the start of the next bit (104 usec)
#define BIT_TIME 104

// Wait time between two bits (69 usec)
#define BIT_WAIT_TIME 69

// Duration of a bit pulse (35 usec)
#define BIT_PULSE_TIME 35

// Maximum time from start bit to stop bit of a byte, including a safety extra
// (roughly 10.5 * BIT_TIME)
#define MAX_BYTE_TIME 1090


//----- exported variables -----

// The telegram buffer for receiving
unsigned char sbRecvTelegram[TELEGRAM_SIZE];

// The size of the received telegram in bytes. 0 if no telegram was received.
unsigned short sbRecvTelegramLen;

// The telegram buffer for sending
unsigned char sbSendTelegram[TELEGRAM_SIZE];

// The size of the to be sent telegram in bytes (including the checksum).
unsigned short sbSendTelegramLen;

// The telegram that is currently being sent.
unsigned char *sbSendCurTelegram;

// The telegram to be sent after sbSendTelegram is done.
unsigned char *sbSendNextTelegram;

// Send an acknowledge or not-acknowledge byte if != 0
unsigned char sbSendAck;

//----- private variables -----


// The number of the next byte in the telegram
static short sbNextByte;

// The number of repeats when sending a telegram
static short sbSendTelegramTries;


// Telegram repeat flag in byte #0 of the telegram: 1=not repeated, 0=repeated
#define SB_TEL_REPEAT_FLAG 0x20

static int debugLine = 0;


Bus::Bus(Timer& aTimer, int aRxPin, int aTxPin, byte aCaptureChannel, byte aMatchChannel)
:timer(aTimer)
,txPin(aTxPin)
,rxCaptureChannel(aCaptureChannel)
,txMatchChannel(aMatchChannel)
,timeMatchChannel((aMatchChannel + 2) & 3)
,ownAddr(0)
,sendTelegram(0)
,sendQueuedTelegram(0)
{
    pinMode(aRxPin, INPUT_CAPTURE | HYSTERESIS);
    pinMode(aTxPin, OUTPUT_MATCH);

    // Configure debug pins

    D(pinMode(PIO3_0, OUTPUT));
    D(pinMode(PIO3_1, OUTPUT));
    D(pinMode(PIO3_2, OUTPUT));
    D(pinMode(PIO3_3, OUTPUT));
    D(pinMode(PIO0_6, OUTPUT));

    D(digitalWrite(PIO3_0, 0));
    D(digitalWrite(PIO3_1, 0));
    D(digitalWrite(PIO3_2, 0));
    D(digitalWrite(PIO3_3, 0));
    D(digitalWrite(PIO0_6, 0));
}

void Bus::begin()
{
    timer.begin();

    // Let the timer count microseconds
    timer.prescaler(SystemCoreClock / 1000000 - 1);

    timer.match(txMatchChannel, 0);
    timer.matchMode(txMatchChannel, SET);
    timer.pwmEnable(txMatchChannel);

    timer.match(timeMatchChannel, 0xffff);
    timer.matchMode(timeMatchChannel, DISABLE);

    timer.captureMode(rxCaptureChannel, FALLING_EDGE | INTERRUPT);

    ownAddr = 0x11fe;  // FIXME should be: (sbEeprom->addrTab[0] << 8) | sbEeprom->addrTab[1];

    state = Bus::IDLE;

    sbSendAck = 0;
    sbSendTelegram[0] = 0;
    sbSendCurTelegram = 0;
    sbSendNextTelegram = 0;
    sbRecvTelegramLen = 0;

    timer.interrupts();
    timer.start();
}

void Bus::end()
{
    timer.end();
}

void Bus::send(byte* telegram, int size)
{
    prepare(telegram, size);

    // Wait until there is space for queing the telegram
    while (sendQueuedTelegram)
        ;

    timer.noInterrupts();
    if (!sbSendCurTelegram) sbSendCurTelegram = telegram;
    else if (!sbSendNextTelegram) sbSendNextTelegram = telegram;
    else fatalError();   // soft fault: send buffer overflow
    timer.interrupts();

    // Start sending if the bus is idle
    if (state == Bus::IDLE)
    {
        sbSendTelegramTries = 0;
        state = Bus::SEND_INIT;
        debugLine = __LINE__;

        timer.matchMode(timeMatchChannel, INTERRUPT | RESET);
        timer.match(timeMatchChannel, 100);
        timer.value(99);
    }
}

void Bus::prepare(byte* telegram, int length) const
{
    unsigned char checksum = 0xff;
    unsigned short i;

    // Set the sender address
    telegram[1] = ownAddr >> 8;
    telegram[2] = ownAddr;

    // Calculate the checksum
    for (i = 0; i < length; ++i)
        checksum ^= telegram[i];
    telegram[length] = checksum;
}

void Bus::idleState()
{
    timer.matchMode(timeMatchChannel, DISABLE);
    timer.captureMode(rxCaptureChannel, FALLING_EDGE | INTERRUPT);

    state = Bus::IDLE;
    sbSendAck = 0;

    digitalWrite(txPin, 0);
    timer.pwmDisable(txMatchChannel);

//  Original code:
//    GPIOSetValue(BUS_OUT_PORT_PIN, 0);       // Set bus-out pin to 0
//    LPC_IOCON_BUS_OUT &= ~(LPC_IOCON_BUS_OUT | BUS_OUT_IOCON_PWM); // Disable bus-out output
}

int Bus::sb_index_of_group_addr(int addr) const
{
    // FIXME dummy implementation
    return 1;
}

void Bus::sb_handle_tel(bool valid)
{
    D(digitalWrite(PIO3_3, 1));         // purple: end of telegram

    if (sbNextByte >= 8 && valid) // Received a valid telegram with correct checksum
    {
        int destAddr = (sbRecvTelegram[3] << 8) | sbRecvTelegram[4];
        bool processTel = false;

        // We ACK the telegram only if it's for us
        if (sbRecvTelegram[5] & 0x80)
        {
            if (destAddr == 0 || sb_index_of_group_addr(destAddr))
                processTel = true;
        }
        else if (destAddr == ownAddr)
        {
            processTel = true;
        }

        // Only process the telegram if it is for us
        if (processTel)
        {
            sbRecvTelegramLen = sbNextByte;
            sbSendAck = Bus::ACK;
        }
    }
    else if (sbNextByte == 1)   // Received a spike or a bus acknowledgment
    {
        currentByte &= 0xff;

        if ((currentByte == Bus::ACK || sbSendTelegramTries >= 3) && sbSendCurTelegram)
        {
            // Prepare the next telegram for sending
            sbSendCurTelegram[0] = 0;
            sbSendCurTelegram = sbSendNextTelegram;
            sbSendNextTelegram = 0;
            sbSendTelegramTries = 0;
            sbSendTelegramLen = 0;
        }
    }
    else // Received more than one byte, but too short for a telegram or wrong checksum
    {
        sbRecvTelegramLen = 0;
        sbSendAck = Bus::NACK;
    }

    timer.matchMode(timeMatchChannel, INTERRUPT | RESET);
    state = Bus::SEND_INIT;  // might be changed by idleState() below
    debugLine = __LINE__;

    int timeout = 0;
    if (sbSendAck)
    {
        // Wait before sending the bus acknowledgement
        timeout = BIT_TIME * 11 + (BIT_TIME >> 1);
    }
    else if (sbSendCurTelegram)
    {
        // Wait at least 50 bit times before sending
        timeout = BIT_TIME * 50;
    }
    else idleState();

    if (timeout)
    {
        timer.matchMode(timeMatchChannel, INTERRUPT | RESET);
        timer.match(timeMatchChannel, timeout);
    }
}

void Bus::timerInterruptHandler()
{
    unsigned int val, captureTime;
    byte timerIntFlags = timer.flags();
    D(static int tick = 0);

    // Debug output
    D(digitalWrite(PIO0_6, ++tick & 1));  // brown: interrupt tick
    D(digitalWrite(PIO3_0, state==Bus::SEND_BIT_0)); // red
    D(digitalWrite(PIO3_1, 0));           // orange
    D(digitalWrite(PIO3_2, 0));               // yellow: end of byte
    D(digitalWrite(PIO3_3, 0));              // purple: end of telegram

STATE_LOOP:
    switch (state)
    {
    case Bus::IDLE:
        if (timerIntFlags & (1 << timeMatchChannel)) // Timeout: do nothing
            break;
        sbSendAck = 0;
        sbNextByte = 0;
        checksum = 0xff;
        valid = true;
        // no break here

    case Bus::RECV_START:
        D(digitalWrite(PIO3_1, 1));   // orange
        if (timerIntFlags & (1 << timeMatchChannel)) // Timeout while waiting for the next start byte
        {
            sb_handle_tel(valid && !checksum);
            break;
        }
        LPC_TMR16B1->MR3 = MAX_BYTE_TIME;
        LPC_TMR16B1->TCR = 2;       // Reset the timer
        LPC_TMR16B1->TCR = 1;       // Enable the timer
        LPC_TMR16B1->MCR = 0x600;   // Interrupt and reset timer on timeout (match of MR3)
        state = Bus::RECV_BYTE;
        currentByte = 0;
        bitTime = 0;
        bitMask = 1;
        parity = true;
        break;

    case Bus::RECV_BYTE:
        if (LPC_TMR16B1->IR & 0x08)
            captureTime = MAX_BYTE_TIME;
        else captureTime = timer.capture(rxCaptureChannel);

        if (captureTime >= bitTime + BIT_WAIT_TIME)
        {
            bitTime += BIT_TIME;
            while (captureTime >= bitTime + BIT_WAIT_TIME && bitMask <= 0x100)
            {
                currentByte |= bitMask;
                parity = !parity;

                bitTime += BIT_TIME;
                bitMask <<= 1;
            }

            bitMask <<= 1;
        }

        if (LPC_TMR16B1->IR & 0x08)  // Timer timeout: end of byte
        {
            D(digitalWrite(PIO3_2, 1));        // yellow: end of byte
//            D(digitalWrite(PIO3_1, parity)); // orange: parity bit ok

            valid &= parity;
            if (sbNextByte < TELEGRAM_SIZE)
            {
                sbRecvTelegram[sbNextByte++] = currentByte;
                checksum ^= currentByte;
            }

            state = Bus::RECV_START;                    // wait for the next byte's start bit
            timer.match(timeMatchChannel, BIT_TIME << 2); // timeout for waiting
        }
        break;

    case Bus::SEND_INIT:
        if (!sbSendAck && !sbSendCurTelegram)
        {
            idleState();
            break;
        }

        state = Bus::SEND_START;
        if (sbSendCurTelegram)
            sbSendTelegramLen = sb_tel_length(sbSendCurTelegram) + 1;
        else sbSendTelegramLen = 0;
        // No break here

    case Bus::SEND_START:
#ifdef DEBUG
        if (!sbSendAck && !sbSendCurTelegram)
            fatalError();
#endif
        if (!sbSendAck)
        {
            if (sbSendTelegramTries == 1)
            {
                // If it is the first repeat, then mark the telegram as being repeated and correct the checksum
                sbSendCurTelegram[0] &= ~SB_TEL_REPEAT_FLAG;
                sbSendCurTelegram[sbSendTelegramLen - 1] ^= SB_TEL_REPEAT_FLAG;
            }

            ++sbSendTelegramTries;
        }

        timer.match(txMatchChannel, BIT_WAIT_TIME); // Set the output to 1 after the wait time
        timer.match(timeMatchChannel, BIT_TIME);    // Interrupt after bit time

        if (state != Bus::SEND_START) // do nothing if the bus is busy
            return;

        timer.pwmEnable(txMatchChannel);
        timer.value(BIT_WAIT_TIME);     // Change the timer to have a 1 almost immediately
        timer.matchMode(timeMatchChannel, INTERRUPT | RESET);
        timer.captureMode(FALLING_EDGE);
        D(digitalWrite(PIO3_2, 1));     // yellow: start of byte
        state = Bus::SEND_BIT_0;
        sbNextByte = 0;
        break;

    case Bus::SEND_BIT_0:
        state = Bus::SEND_BYTE;

        if (sbSendAck)
            currentByte = sbSendAck;
        else currentByte = sbSendCurTelegram[sbNextByte++];

        // Calculate the parity bit
        for (bitMask = 1; bitMask < 0x100; bitMask <<= 1)
        {
            if (currentByte & bitMask) currentByte ^= 0x100;
        }
        bitMask = 1;
        // no break here

    case Bus::SEND_BYTE:
        D(digitalWrite(PIO3_2, 1));      // yellow: send next bits
        captureTime = BIT_TIME;
        while ((currentByte & bitMask) && bitMask <= 0x100)
        {
            bitMask <<= 1;
            captureTime += BIT_TIME;
        }
        bitMask <<= 1;

        if (bitMask > 0x200)
        {
            captureTime += BIT_TIME * 3; // Stop bit + inter-byte timeout

            if (sbNextByte < sbSendTelegramLen && !sbSendAck)
            {
                state = Bus::SEND_BIT_0;
            }
            else
            {
                state = Bus::SEND_END;
                timer.pwmDisable(txMatchChannel); // Disable bus-out output
                // original code: LPC_IOCON_BUS_OUT &= ~(LPC_IOCON_BUS_OUT | BUS_OUT_IOCON_PWM);
            }
        }
        timer.match(timeMatchChannel, captureTime);   // Reset and interrupt at the next 0 bit
        timer.match(txMatchChannel, captureTime - BIT_PULSE_TIME);
        break;

    case Bus::SEND_END:
        timer.match(timeMatchChannel, BIT_TIME * 50);
        timer.matchMode(timeMatchChannel, INTERRUPT | RESET);
        timer.captureMode(rxCaptureChannel, FALLING_EDGE | INTERRUPT);

        sbSendAck = 0;
        state = Bus::SEND_WAIT;   // Wait for ACK or resend / send next telegram
        break;

    case Bus::SEND_WAIT:
        if (!(LPC_TMR16B1->IR & 0x08)) // Start receiving if its not a timeout
        {
            state = Bus::IDLE;
            goto STATE_LOOP;
        }

        // FIXME the next telegram is not sent if sbSendTelegramTries>=3
        if (sbSendAck || (sbSendTelegramLen && sbSendTelegramTries < 3))
        {
            state = Bus::SEND_START;
            debugLine = __LINE__;
            goto STATE_LOOP;
        }
        // no break here

    default:
        idleState();
        break;
    }

    LPC_TMR16B1->IR = 0xff;
}


/**
 * Send a telegram. The checksum byte will be added at the end of telegram[].
 * Ensure that there is at least one byte space at the end of telegram[].
 *
 * @param telegram - the telegram to be sent.
 * @param length - the length of the telegram in sbSendTelegram[], without the checksum
 */
void sb_send_tel(unsigned char* telegram, unsigned short length)
{
}
